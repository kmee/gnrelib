#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jun  6 08:51:33 2018 by generateDS.py version 2.29.15.
# Python 3.6.5 (default, Apr  1 2018, 05:46:30)  [GCC 7.3.0]
#
# Command line options:
#   ('-a', '')
#   ('-o', 'gnrelib/v1_12/config_uf.py')
#
# Command line arguments:
#   schemas/v1.12/config_uf_v1.00.xsd
#
# Command line:
#   /usr/local/bin/generateDS -a -o "gnrelib/v1_12/config_uf.py" schemas/v1.12/config_uf_v1.00.xsd
#
# Current working directory (os.getcwd()):
#   gnrelib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TConfigUf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ambiente=None, uf=None, situacaoConsulta=None, exigeUfFavorecida=None, exigeReceita=None, receitas=None):
        self.original_tagname_ = None
        self.ambiente = ambiente
        self.uf = uf
        self.validate_TUf(self.uf)
        self.situacaoConsulta = situacaoConsulta
        if exigeUfFavorecida is None:
            self.exigeUfFavorecida = globals()['exigeUfFavorecida']('S')
        else:
            self.exigeUfFavorecida = exigeUfFavorecida
        if exigeReceita is None:
            self.exigeReceita = globals()['exigeReceita']('S')
        else:
            self.exigeReceita = exigeReceita
        self.receitas = receitas
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TConfigUf)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TConfigUf.subclass:
            return TConfigUf.subclass(*args_, **kwargs_)
        else:
            return TConfigUf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ambiente(self): return self.ambiente
    def set_ambiente(self, ambiente): self.ambiente = ambiente
    def get_uf(self): return self.uf
    def set_uf(self, uf): self.uf = uf
    def get_situacaoConsulta(self): return self.situacaoConsulta
    def set_situacaoConsulta(self, situacaoConsulta): self.situacaoConsulta = situacaoConsulta
    def get_exigeUfFavorecida(self): return self.exigeUfFavorecida
    def set_exigeUfFavorecida(self, exigeUfFavorecida): self.exigeUfFavorecida = exigeUfFavorecida
    def get_exigeReceita(self): return self.exigeReceita
    def set_exigeReceita(self, exigeReceita): self.exigeReceita = exigeReceita
    def get_receitas(self): return self.receitas
    def set_receitas(self, receitas): self.receitas = receitas
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ambiente is not None or
            self.uf is not None or
            self.situacaoConsulta is not None or
            self.exigeUfFavorecida != S or
            self.exigeReceita != S or
            self.receitas is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TConfigUf', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TConfigUf')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TConfigUf')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TConfigUf', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TConfigUf'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TConfigUf', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ambiente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:ambiente>%s</tns:ambiente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ambiente), input_name='ambiente')), eol_))
        if self.uf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:uf>%s</tns:uf>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.uf), input_name='uf')), eol_))
        if self.situacaoConsulta is not None:
            self.situacaoConsulta.export(outfile, level, namespace_, name_='situacaoConsulta', pretty_print=pretty_print)
        if self.exigeUfFavorecida is not None:
            self.exigeUfFavorecida.export(outfile, level, namespace_, name_='exigeUfFavorecida', pretty_print=pretty_print)
        if self.exigeReceita is not None:
            self.exigeReceita.export(outfile, level, namespace_, name_='exigeReceita', pretty_print=pretty_print)
        if self.receitas is not None:
            self.receitas.export(outfile, level, namespace_, name_='receitas', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ambiente':
            ambiente_ = child_.text
            ambiente_ = self.gds_validate_string(ambiente_, node, 'ambiente')
            self.ambiente = ambiente_
        elif nodeName_ == 'uf':
            uf_ = child_.text
            uf_ = self.gds_validate_string(uf_, node, 'uf')
            self.uf = uf_
            # validate type TUf
            self.validate_TUf(self.uf)
        elif nodeName_ == 'situacaoConsulta':
            obj_ = situacaoConsulta.factory()
            obj_.build(child_)
            self.situacaoConsulta = obj_
            obj_.original_tagname_ = 'situacaoConsulta'
        elif nodeName_ == 'exigeUfFavorecida':
            obj_ = exigeUfFavorecida.factory()
            obj_.build(child_)
            self.exigeUfFavorecida = obj_
            obj_.original_tagname_ = 'exigeUfFavorecida'
        elif nodeName_ == 'exigeReceita':
            obj_ = exigeReceita.factory()
            obj_.build(child_)
            self.exigeReceita = obj_
            obj_.original_tagname_ = 'exigeReceita'
        elif nodeName_ == 'receitas':
            obj_ = receitas.factory()
            obj_.build(child_)
            self.receitas = obj_
            obj_.original_tagname_ = 'receitas'
# end class TConfigUf


class ambiente(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ambiente)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ambiente.subclass:
            return ambiente.subclass(*args_, **kwargs_)
        else:
            return ambiente(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ambiente', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ambiente')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ambiente')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ambiente', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ambiente'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ambiente', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ambiente


class situacaoConsulta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, descricao=None):
        self.original_tagname_ = None
        self.codigo = codigo
        self.descricao = descricao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, situacaoConsulta)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if situacaoConsulta.subclass:
            return situacaoConsulta.subclass(*args_, **kwargs_)
        else:
            return situacaoConsulta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_descricao(self): return self.descricao
    def set_descricao(self, descricao): self.descricao = descricao
    def hasContent_(self):
        if (
            self.codigo is not None or
            self.descricao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='situacaoConsulta', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('situacaoConsulta')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='situacaoConsulta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='situacaoConsulta', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='situacaoConsulta'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='situacaoConsulta', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:codigo>%s</tns:codigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codigo), input_name='codigo')), eol_))
        if self.descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:descricao>%s</tns:descricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descricao), input_name='descricao')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codigo':
            codigo_ = child_.text
            codigo_ = self.gds_validate_string(codigo_, node, 'codigo')
            self.codigo = codigo_
        elif nodeName_ == 'descricao':
            descricao_ = child_.text
            descricao_ = self.gds_validate_string(descricao_, node, 'descricao')
            self.descricao = descricao_
# end class situacaoConsulta


class codigo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, codigo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if codigo.subclass:
            return codigo.subclass(*args_, **kwargs_)
        else:
            return codigo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codigo', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('codigo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codigo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codigo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codigo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='codigo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class codigo


class descricao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, descricao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if descricao.subclass:
            return descricao.subclass(*args_, **kwargs_)
        else:
            return descricao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='descricao', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('descricao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='descricao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='descricao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='descricao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='descricao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class descricao


class exigeUfFavorecida(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c01_UfFavorecida', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeUfFavorecida)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeUfFavorecida.subclass:
            return exigeUfFavorecida.subclass(*args_, **kwargs_)
        else:
            return exigeUfFavorecida(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeUfFavorecida', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeUfFavorecida')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeUfFavorecida')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeUfFavorecida', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeUfFavorecida'):
        if self.campo != "c01_UfFavorecida" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeUfFavorecida', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeUfFavorecida


class exigeReceita(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c02_receita', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeReceita)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeReceita.subclass:
            return exigeReceita.subclass(*args_, **kwargs_)
        else:
            return exigeReceita(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeReceita', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeReceita')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeReceita')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeReceita', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeReceita'):
        if self.campo != "c02_receita" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeReceita', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeReceita


class receitas(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, receita=None):
        self.original_tagname_ = None
        if receita is None:
            self.receita = []
        else:
            self.receita = receita
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, receitas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if receitas.subclass:
            return receitas.subclass(*args_, **kwargs_)
        else:
            return receitas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_receita(self): return self.receita
    def set_receita(self, receita): self.receita = receita
    def add_receita(self, value): self.receita.append(value)
    def insert_receita_at(self, index, value): self.receita.insert(index, value)
    def replace_receita_at(self, index, value): self.receita[index] = value
    def hasContent_(self):
        if (
            self.receita
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='receitas', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('receitas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='receitas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='receitas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='receitas'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='receitas', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for receita_ in self.receita:
            receita_.export(outfile, level, namespace_, name_='receita', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'receita':
            obj_ = receita.factory()
            obj_.build(child_)
            self.receita.append(obj_)
            obj_.original_tagname_ = 'receita'
# end class receitas


class receita(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, descricao=None, courier='N', exigeContribuinteEmitente='S', exigeDetalhamentoReceita=None, detalhamentosReceita=None, exigeProduto=None, produtos=None, exigePeriodoReferencia=None, exigePeriodoApuracao=None, periodosApuracao=None, exigeParcela=None, valorExigido=None, exigeDocumentoOrigem=None, tiposDocumentosOrigem=None, exigeContribuinteDestinatario=None, exigeDataVencimento=None, exigeDataPagamento=None, exigeConvenio=None, exigeCamposAdicionais=None, camposAdicionais=None):
        self.original_tagname_ = None
        self.codigo = _cast(None, codigo)
        self.descricao = _cast(None, descricao)
        self.courier = _cast(None, courier)
        self.exigeContribuinteEmitente = exigeContribuinteEmitente
        self.validate_TSimNao(self.exigeContribuinteEmitente)
        self.exigeDetalhamentoReceita = exigeDetalhamentoReceita
        self.detalhamentosReceita = detalhamentosReceita
        self.exigeProduto = exigeProduto
        self.produtos = produtos
        self.exigePeriodoReferencia = exigePeriodoReferencia
        self.exigePeriodoApuracao = exigePeriodoApuracao
        self.periodosApuracao = periodosApuracao
        self.exigeParcela = exigeParcela
        self.valorExigido = valorExigido
        self.exigeDocumentoOrigem = exigeDocumentoOrigem
        self.tiposDocumentosOrigem = tiposDocumentosOrigem
        self.exigeContribuinteDestinatario = exigeContribuinteDestinatario
        self.validate_TSimNao(self.exigeContribuinteDestinatario)
        if exigeDataVencimento is None:
            self.exigeDataVencimento = globals()['exigeDataVencimento']('S')
        else:
            self.exigeDataVencimento = exigeDataVencimento
        if exigeDataPagamento is None:
            self.exigeDataPagamento = globals()['exigeDataPagamento']('S')
        else:
            self.exigeDataPagamento = exigeDataPagamento
        if exigeConvenio is None:
            self.exigeConvenio = globals()['exigeConvenio']('N')
        else:
            self.exigeConvenio = exigeConvenio
        self.exigeCamposAdicionais = exigeCamposAdicionais
        self.camposAdicionais = camposAdicionais
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, receita)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if receita.subclass:
            return receita.subclass(*args_, **kwargs_)
        else:
            return receita(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exigeContribuinteEmitente(self): return self.exigeContribuinteEmitente
    def set_exigeContribuinteEmitente(self, exigeContribuinteEmitente): self.exigeContribuinteEmitente = exigeContribuinteEmitente
    def get_exigeDetalhamentoReceita(self): return self.exigeDetalhamentoReceita
    def set_exigeDetalhamentoReceita(self, exigeDetalhamentoReceita): self.exigeDetalhamentoReceita = exigeDetalhamentoReceita
    def get_detalhamentosReceita(self): return self.detalhamentosReceita
    def set_detalhamentosReceita(self, detalhamentosReceita): self.detalhamentosReceita = detalhamentosReceita
    def get_exigeProduto(self): return self.exigeProduto
    def set_exigeProduto(self, exigeProduto): self.exigeProduto = exigeProduto
    def get_produtos(self): return self.produtos
    def set_produtos(self, produtos): self.produtos = produtos
    def get_exigePeriodoReferencia(self): return self.exigePeriodoReferencia
    def set_exigePeriodoReferencia(self, exigePeriodoReferencia): self.exigePeriodoReferencia = exigePeriodoReferencia
    def get_exigePeriodoApuracao(self): return self.exigePeriodoApuracao
    def set_exigePeriodoApuracao(self, exigePeriodoApuracao): self.exigePeriodoApuracao = exigePeriodoApuracao
    def get_periodosApuracao(self): return self.periodosApuracao
    def set_periodosApuracao(self, periodosApuracao): self.periodosApuracao = periodosApuracao
    def get_exigeParcela(self): return self.exigeParcela
    def set_exigeParcela(self, exigeParcela): self.exigeParcela = exigeParcela
    def get_valorExigido(self): return self.valorExigido
    def set_valorExigido(self, valorExigido): self.valorExigido = valorExigido
    def get_exigeDocumentoOrigem(self): return self.exigeDocumentoOrigem
    def set_exigeDocumentoOrigem(self, exigeDocumentoOrigem): self.exigeDocumentoOrigem = exigeDocumentoOrigem
    def get_tiposDocumentosOrigem(self): return self.tiposDocumentosOrigem
    def set_tiposDocumentosOrigem(self, tiposDocumentosOrigem): self.tiposDocumentosOrigem = tiposDocumentosOrigem
    def get_exigeContribuinteDestinatario(self): return self.exigeContribuinteDestinatario
    def set_exigeContribuinteDestinatario(self, exigeContribuinteDestinatario): self.exigeContribuinteDestinatario = exigeContribuinteDestinatario
    def get_exigeDataVencimento(self): return self.exigeDataVencimento
    def set_exigeDataVencimento(self, exigeDataVencimento): self.exigeDataVencimento = exigeDataVencimento
    def get_exigeDataPagamento(self): return self.exigeDataPagamento
    def set_exigeDataPagamento(self, exigeDataPagamento): self.exigeDataPagamento = exigeDataPagamento
    def get_exigeConvenio(self): return self.exigeConvenio
    def set_exigeConvenio(self, exigeConvenio): self.exigeConvenio = exigeConvenio
    def get_exigeCamposAdicionais(self): return self.exigeCamposAdicionais
    def set_exigeCamposAdicionais(self, exigeCamposAdicionais): self.exigeCamposAdicionais = exigeCamposAdicionais
    def get_camposAdicionais(self): return self.camposAdicionais
    def set_camposAdicionais(self, camposAdicionais): self.camposAdicionais = camposAdicionais
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_descricao(self): return self.descricao
    def set_descricao(self, descricao): self.descricao = descricao
    def get_courier(self): return self.courier
    def set_courier(self, courier): self.courier = courier
    def validate_TSimNao(self, value):
        # Validate type TSimNao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TSimNao' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.exigeContribuinteEmitente != "S" or
            self.exigeDetalhamentoReceita is not None or
            self.detalhamentosReceita is not None or
            self.exigeProduto is not None or
            self.produtos is not None or
            self.exigePeriodoReferencia is not None or
            self.exigePeriodoApuracao is not None or
            self.periodosApuracao is not None or
            self.exigeParcela is not None or
            self.valorExigido is not None or
            self.exigeDocumentoOrigem is not None or
            self.tiposDocumentosOrigem is not None or
            self.exigeContribuinteDestinatario is not None or
            self.exigeDataVencimento != S or
            self.exigeDataPagamento != S or
            self.exigeConvenio != N or
            self.exigeCamposAdicionais is not None or
            self.camposAdicionais is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='receita', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('receita')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='receita')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='receita', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='receita'):
        if self.codigo is not None and 'codigo' not in already_processed:
            already_processed.add('codigo')
            outfile.write(' codigo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.codigo), input_name='codigo')), ))
        if self.descricao is not None and 'descricao' not in already_processed:
            already_processed.add('descricao')
            outfile.write(' descricao=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.descricao), input_name='descricao')), ))
        if self.courier != "N" and 'courier' not in already_processed:
            already_processed.add('courier')
            outfile.write(' courier=%s' % (quote_attrib(self.courier), ))
    def exportChildren(self, outfile, level, namespace_='', name_='receita', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exigeContribuinteEmitente != "S":
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:exigeContribuinteEmitente>%s</tns:exigeContribuinteEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.exigeContribuinteEmitente), input_name='exigeContribuinteEmitente')), eol_))
        if self.exigeDetalhamentoReceita is not None:
            self.exigeDetalhamentoReceita.export(outfile, level, namespace_, name_='exigeDetalhamentoReceita', pretty_print=pretty_print)
        if self.detalhamentosReceita is not None:
            self.detalhamentosReceita.export(outfile, level, namespace_, name_='detalhamentosReceita', pretty_print=pretty_print)
        if self.exigeProduto is not None:
            self.exigeProduto.export(outfile, level, namespace_, name_='exigeProduto', pretty_print=pretty_print)
        if self.produtos is not None:
            self.produtos.export(outfile, level, namespace_, name_='produtos', pretty_print=pretty_print)
        if self.exigePeriodoReferencia is not None:
            self.exigePeriodoReferencia.export(outfile, level, namespace_, name_='exigePeriodoReferencia', pretty_print=pretty_print)
        if self.exigePeriodoApuracao is not None:
            self.exigePeriodoApuracao.export(outfile, level, namespace_, name_='exigePeriodoApuracao', pretty_print=pretty_print)
        if self.periodosApuracao is not None:
            self.periodosApuracao.export(outfile, level, namespace_, name_='periodosApuracao', pretty_print=pretty_print)
        if self.exigeParcela is not None:
            self.exigeParcela.export(outfile, level, namespace_, name_='exigeParcela', pretty_print=pretty_print)
        if self.valorExigido is not None:
            self.valorExigido.export(outfile, level, namespace_, name_='valorExigido', pretty_print=pretty_print)
        if self.exigeDocumentoOrigem is not None:
            self.exigeDocumentoOrigem.export(outfile, level, namespace_, name_='exigeDocumentoOrigem', pretty_print=pretty_print)
        if self.tiposDocumentosOrigem is not None:
            self.tiposDocumentosOrigem.export(outfile, level, namespace_, name_='tiposDocumentosOrigem', pretty_print=pretty_print)
        if self.exigeContribuinteDestinatario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:exigeContribuinteDestinatario>%s</tns:exigeContribuinteDestinatario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.exigeContribuinteDestinatario), input_name='exigeContribuinteDestinatario')), eol_))
        if self.exigeDataVencimento is not None:
            self.exigeDataVencimento.export(outfile, level, namespace_, name_='exigeDataVencimento', pretty_print=pretty_print)
        if self.exigeDataPagamento is not None:
            self.exigeDataPagamento.export(outfile, level, namespace_, name_='exigeDataPagamento', pretty_print=pretty_print)
        if self.exigeConvenio is not None:
            self.exigeConvenio.export(outfile, level, namespace_, name_='exigeConvenio', pretty_print=pretty_print)
        if self.exigeCamposAdicionais is not None:
            self.exigeCamposAdicionais.export(outfile, level, namespace_, name_='exigeCamposAdicionais', pretty_print=pretty_print)
        if self.camposAdicionais is not None:
            self.camposAdicionais.export(outfile, level, namespace_, name_='camposAdicionais', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codigo', node)
        if value is not None and 'codigo' not in already_processed:
            already_processed.add('codigo')
            self.codigo = value
        value = find_attr_value_('descricao', node)
        if value is not None and 'descricao' not in already_processed:
            already_processed.add('descricao')
            self.descricao = value
        value = find_attr_value_('courier', node)
        if value is not None and 'courier' not in already_processed:
            already_processed.add('courier')
            self.courier = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exigeContribuinteEmitente':
            exigeContribuinteEmitente_ = child_.text
            exigeContribuinteEmitente_ = self.gds_validate_string(exigeContribuinteEmitente_, node, 'exigeContribuinteEmitente')
            self.exigeContribuinteEmitente = exigeContribuinteEmitente_
            # validate type TSimNao
            self.validate_TSimNao(self.exigeContribuinteEmitente)
        elif nodeName_ == 'exigeDetalhamentoReceita':
            obj_ = exigeDetalhamentoReceita.factory()
            obj_.build(child_)
            self.exigeDetalhamentoReceita = obj_
            obj_.original_tagname_ = 'exigeDetalhamentoReceita'
        elif nodeName_ == 'detalhamentosReceita':
            obj_ = detalhamentosReceita.factory()
            obj_.build(child_)
            self.detalhamentosReceita = obj_
            obj_.original_tagname_ = 'detalhamentosReceita'
        elif nodeName_ == 'exigeProduto':
            obj_ = exigeProduto.factory()
            obj_.build(child_)
            self.exigeProduto = obj_
            obj_.original_tagname_ = 'exigeProduto'
        elif nodeName_ == 'produtos':
            obj_ = produtos.factory()
            obj_.build(child_)
            self.produtos = obj_
            obj_.original_tagname_ = 'produtos'
        elif nodeName_ == 'exigePeriodoReferencia':
            obj_ = exigePeriodoReferencia.factory()
            obj_.build(child_)
            self.exigePeriodoReferencia = obj_
            obj_.original_tagname_ = 'exigePeriodoReferencia'
        elif nodeName_ == 'exigePeriodoApuracao':
            obj_ = exigePeriodoApuracao.factory()
            obj_.build(child_)
            self.exigePeriodoApuracao = obj_
            obj_.original_tagname_ = 'exigePeriodoApuracao'
        elif nodeName_ == 'periodosApuracao':
            obj_ = periodosApuracao.factory()
            obj_.build(child_)
            self.periodosApuracao = obj_
            obj_.original_tagname_ = 'periodosApuracao'
        elif nodeName_ == 'exigeParcela':
            obj_ = exigeParcela.factory()
            obj_.build(child_)
            self.exigeParcela = obj_
            obj_.original_tagname_ = 'exigeParcela'
        elif nodeName_ == 'valorExigido':
            obj_ = valorExigido.factory()
            obj_.build(child_)
            self.valorExigido = obj_
            obj_.original_tagname_ = 'valorExigido'
        elif nodeName_ == 'exigeDocumentoOrigem':
            obj_ = exigeDocumentoOrigem.factory()
            obj_.build(child_)
            self.exigeDocumentoOrigem = obj_
            obj_.original_tagname_ = 'exigeDocumentoOrigem'
        elif nodeName_ == 'tiposDocumentosOrigem':
            obj_ = tiposDocumentosOrigem.factory()
            obj_.build(child_)
            self.tiposDocumentosOrigem = obj_
            obj_.original_tagname_ = 'tiposDocumentosOrigem'
        elif nodeName_ == 'exigeContribuinteDestinatario':
            exigeContribuinteDestinatario_ = child_.text
            exigeContribuinteDestinatario_ = self.gds_validate_string(exigeContribuinteDestinatario_, node, 'exigeContribuinteDestinatario')
            self.exigeContribuinteDestinatario = exigeContribuinteDestinatario_
            # validate type TSimNao
            self.validate_TSimNao(self.exigeContribuinteDestinatario)
        elif nodeName_ == 'exigeDataVencimento':
            obj_ = exigeDataVencimento.factory()
            obj_.build(child_)
            self.exigeDataVencimento = obj_
            obj_.original_tagname_ = 'exigeDataVencimento'
        elif nodeName_ == 'exigeDataPagamento':
            obj_ = exigeDataPagamento.factory()
            obj_.build(child_)
            self.exigeDataPagamento = obj_
            obj_.original_tagname_ = 'exigeDataPagamento'
        elif nodeName_ == 'exigeConvenio':
            obj_ = exigeConvenio.factory()
            obj_.build(child_)
            self.exigeConvenio = obj_
            obj_.original_tagname_ = 'exigeConvenio'
        elif nodeName_ == 'exigeCamposAdicionais':
            obj_ = exigeCamposAdicionais.factory()
            obj_.build(child_)
            self.exigeCamposAdicionais = obj_
            obj_.original_tagname_ = 'exigeCamposAdicionais'
        elif nodeName_ == 'camposAdicionais':
            obj_ = camposAdicionais.factory()
            obj_.build(child_)
            self.camposAdicionais = obj_
            obj_.original_tagname_ = 'camposAdicionais'
# end class receita


class exigeDetalhamentoReceita(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c25_detalhamentoReceita', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeDetalhamentoReceita)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeDetalhamentoReceita.subclass:
            return exigeDetalhamentoReceita.subclass(*args_, **kwargs_)
        else:
            return exigeDetalhamentoReceita(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeDetalhamentoReceita', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeDetalhamentoReceita')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeDetalhamentoReceita')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeDetalhamentoReceita', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeDetalhamentoReceita'):
        if self.campo != "c25_detalhamentoReceita" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeDetalhamentoReceita', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeDetalhamentoReceita


class detalhamentosReceita(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, detalhamentoReceita=None):
        self.original_tagname_ = None
        if detalhamentoReceita is None:
            self.detalhamentoReceita = []
        else:
            self.detalhamentoReceita = detalhamentoReceita
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detalhamentosReceita)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detalhamentosReceita.subclass:
            return detalhamentosReceita.subclass(*args_, **kwargs_)
        else:
            return detalhamentosReceita(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_detalhamentoReceita(self): return self.detalhamentoReceita
    def set_detalhamentoReceita(self, detalhamentoReceita): self.detalhamentoReceita = detalhamentoReceita
    def add_detalhamentoReceita(self, value): self.detalhamentoReceita.append(value)
    def insert_detalhamentoReceita_at(self, index, value): self.detalhamentoReceita.insert(index, value)
    def replace_detalhamentoReceita_at(self, index, value): self.detalhamentoReceita[index] = value
    def hasContent_(self):
        if (
            self.detalhamentoReceita
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detalhamentosReceita', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detalhamentosReceita')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detalhamentosReceita')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detalhamentosReceita', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detalhamentosReceita'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detalhamentosReceita', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detalhamentoReceita_ in self.detalhamentoReceita:
            detalhamentoReceita_.export(outfile, level, namespace_, name_='detalhamentoReceita', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'detalhamentoReceita':
            obj_ = detalhamentoReceita.factory()
            obj_.build(child_)
            self.detalhamentoReceita.append(obj_)
            obj_.original_tagname_ = 'detalhamentoReceita'
# end class detalhamentosReceita


class detalhamentoReceita(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, descricao=None):
        self.original_tagname_ = None
        self.codigo = codigo
        self.descricao = descricao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detalhamentoReceita)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detalhamentoReceita.subclass:
            return detalhamentoReceita.subclass(*args_, **kwargs_)
        else:
            return detalhamentoReceita(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_descricao(self): return self.descricao
    def set_descricao(self, descricao): self.descricao = descricao
    def hasContent_(self):
        if (
            self.codigo is not None or
            self.descricao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='detalhamentoReceita', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detalhamentoReceita')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='detalhamentoReceita')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='detalhamentoReceita', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='detalhamentoReceita'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='detalhamentoReceita', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:codigo>%s</tns:codigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codigo), input_name='codigo')), eol_))
        if self.descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:descricao>%s</tns:descricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descricao), input_name='descricao')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codigo':
            codigo_ = child_.text
            codigo_ = self.gds_validate_string(codigo_, node, 'codigo')
            self.codigo = codigo_
        elif nodeName_ == 'descricao':
            descricao_ = child_.text
            descricao_ = self.gds_validate_string(descricao_, node, 'descricao')
            self.descricao = descricao_
# end class detalhamentoReceita


class exigeProduto(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c26_produto', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeProduto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeProduto.subclass:
            return exigeProduto.subclass(*args_, **kwargs_)
        else:
            return exigeProduto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeProduto', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeProduto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeProduto')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeProduto', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeProduto'):
        if self.campo != "c26_produto" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeProduto', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeProduto


class produtos(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, produto=None):
        self.original_tagname_ = None
        if produto is None:
            self.produto = []
        else:
            self.produto = produto
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, produtos)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if produtos.subclass:
            return produtos.subclass(*args_, **kwargs_)
        else:
            return produtos(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_produto(self): return self.produto
    def set_produto(self, produto): self.produto = produto
    def add_produto(self, value): self.produto.append(value)
    def insert_produto_at(self, index, value): self.produto.insert(index, value)
    def replace_produto_at(self, index, value): self.produto[index] = value
    def hasContent_(self):
        if (
            self.produto
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='produtos', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('produtos')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='produtos')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='produtos', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='produtos'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='produtos', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for produto_ in self.produto:
            produto_.export(outfile, level, namespace_, name_='produto', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'produto':
            obj_ = produto.factory()
            obj_.build(child_)
            self.produto.append(obj_)
            obj_.original_tagname_ = 'produto'
# end class produtos


class produto(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, descricao=None):
        self.original_tagname_ = None
        self.codigo = codigo
        self.descricao = descricao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, produto)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if produto.subclass:
            return produto.subclass(*args_, **kwargs_)
        else:
            return produto(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_descricao(self): return self.descricao
    def set_descricao(self, descricao): self.descricao = descricao
    def hasContent_(self):
        if (
            self.codigo is not None or
            self.descricao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='produto', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('produto')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='produto')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='produto', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='produto'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='produto', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:codigo>%s</tns:codigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codigo), input_name='codigo')), eol_))
        if self.descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:descricao>%s</tns:descricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descricao), input_name='descricao')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codigo':
            codigo_ = child_.text
            codigo_ = self.gds_validate_string(codigo_, node, 'codigo')
            self.codigo = codigo_
        elif nodeName_ == 'descricao':
            descricao_ = child_.text
            descricao_ = self.gds_validate_string(descricao_, node, 'descricao')
            self.descricao = descricao_
# end class produto


class exigePeriodoReferencia(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c05_referencia', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigePeriodoReferencia)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigePeriodoReferencia.subclass:
            return exigePeriodoReferencia.subclass(*args_, **kwargs_)
        else:
            return exigePeriodoReferencia(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigePeriodoReferencia', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigePeriodoReferencia')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigePeriodoReferencia')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigePeriodoReferencia', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigePeriodoReferencia'):
        if self.campo != "c05_referencia" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigePeriodoReferencia', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigePeriodoReferencia


class exigePeriodoApuracao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='periodo', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigePeriodoApuracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigePeriodoApuracao.subclass:
            return exigePeriodoApuracao.subclass(*args_, **kwargs_)
        else:
            return exigePeriodoApuracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigePeriodoApuracao', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigePeriodoApuracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigePeriodoApuracao')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigePeriodoApuracao', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigePeriodoApuracao'):
        if self.campo != "periodo" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigePeriodoApuracao', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigePeriodoApuracao


class periodosApuracao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, periodoApuracao=None):
        self.original_tagname_ = None
        if periodoApuracao is None:
            self.periodoApuracao = []
        else:
            self.periodoApuracao = periodoApuracao
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, periodosApuracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if periodosApuracao.subclass:
            return periodosApuracao.subclass(*args_, **kwargs_)
        else:
            return periodosApuracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodoApuracao(self): return self.periodoApuracao
    def set_periodoApuracao(self, periodoApuracao): self.periodoApuracao = periodoApuracao
    def add_periodoApuracao(self, value): self.periodoApuracao.append(value)
    def insert_periodoApuracao_at(self, index, value): self.periodoApuracao.insert(index, value)
    def replace_periodoApuracao_at(self, index, value): self.periodoApuracao[index] = value
    def hasContent_(self):
        if (
            self.periodoApuracao
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periodosApuracao', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('periodosApuracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periodosApuracao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periodosApuracao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periodosApuracao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periodosApuracao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for periodoApuracao_ in self.periodoApuracao:
            periodoApuracao_.export(outfile, level, namespace_, name_='periodoApuracao', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodoApuracao':
            obj_ = periodoApuracao.factory()
            obj_.build(child_)
            self.periodoApuracao.append(obj_)
            obj_.original_tagname_ = 'periodoApuracao'
# end class periodosApuracao


class periodoApuracao(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, descricao=None):
        self.original_tagname_ = None
        self.codigo = codigo
        self.descricao = descricao
        self.validate_TString(self.descricao)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, periodoApuracao)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if periodoApuracao.subclass:
            return periodoApuracao.subclass(*args_, **kwargs_)
        else:
            return periodoApuracao(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_descricao(self): return self.descricao
    def set_descricao(self, descricao): self.descricao = descricao
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.codigo is not None or
            self.descricao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='periodoApuracao', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('periodoApuracao')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='periodoApuracao')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='periodoApuracao', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='periodoApuracao'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='periodoApuracao', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:codigo>%s</tns:codigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codigo), input_name='codigo')), eol_))
        if self.descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:descricao>%s</tns:descricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descricao), input_name='descricao')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codigo':
            codigo_ = child_.text
            codigo_ = self.gds_validate_string(codigo_, node, 'codigo')
            self.codigo = codigo_
        elif nodeName_ == 'descricao':
            descricao_ = child_.text
            descricao_ = self.gds_validate_string(descricao_, node, 'descricao')
            self.descricao = descricao_
            # validate type TString
            self.validate_TString(self.descricao)
# end class periodoApuracao


class exigeParcela(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='parcela', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeParcela)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeParcela.subclass:
            return exigeParcela.subclass(*args_, **kwargs_)
        else:
            return exigeParcela(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeParcela', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeParcela')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeParcela')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeParcela', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeParcela'):
        if self.campo != "parcela" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeParcela', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeParcela


class valorExigido(GeneratedsSuper):
    """P - Valor principal T - Valor total A - Valor principal ou total N -
    Nenhum (Não precisa informar um valor. Será informado pela UF)"""
    subclass = None
    superclass = None
    def __init__(self, campo=None, valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valorExigido)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valorExigido.subclass:
            return valorExigido.subclass(*args_, **kwargs_)
        else:
            return valorExigido(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='valorExigido', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valorExigido')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valorExigido')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='valorExigido', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='valorExigido'):
        if self.campo is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='valorExigido', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class valorExigido


class exigeDocumentoOrigem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c04_docOrigem', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeDocumentoOrigem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeDocumentoOrigem.subclass:
            return exigeDocumentoOrigem.subclass(*args_, **kwargs_)
        else:
            return exigeDocumentoOrigem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeDocumentoOrigem', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeDocumentoOrigem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeDocumentoOrigem')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeDocumentoOrigem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeDocumentoOrigem'):
        if self.campo != "c04_docOrigem" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeDocumentoOrigem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeDocumentoOrigem


class tiposDocumentosOrigem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c28_tipoDocOrigem', tipoDocumentoOrigem=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        if tipoDocumentoOrigem is None:
            self.tipoDocumentoOrigem = []
        else:
            self.tipoDocumentoOrigem = tipoDocumentoOrigem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tiposDocumentosOrigem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tiposDocumentosOrigem.subclass:
            return tiposDocumentosOrigem.subclass(*args_, **kwargs_)
        else:
            return tiposDocumentosOrigem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tipoDocumentoOrigem(self): return self.tipoDocumentoOrigem
    def set_tipoDocumentoOrigem(self, tipoDocumentoOrigem): self.tipoDocumentoOrigem = tipoDocumentoOrigem
    def add_tipoDocumentoOrigem(self, value): self.tipoDocumentoOrigem.append(value)
    def insert_tipoDocumentoOrigem_at(self, index, value): self.tipoDocumentoOrigem.insert(index, value)
    def replace_tipoDocumentoOrigem_at(self, index, value): self.tipoDocumentoOrigem[index] = value
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def hasContent_(self):
        if (
            self.tipoDocumentoOrigem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tiposDocumentosOrigem', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tiposDocumentosOrigem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tiposDocumentosOrigem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tiposDocumentosOrigem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tiposDocumentosOrigem'):
        if self.campo != "c28_tipoDocOrigem" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tiposDocumentosOrigem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tipoDocumentoOrigem_ in self.tipoDocumentoOrigem:
            tipoDocumentoOrigem_.export(outfile, level, namespace_, name_='tipoDocumentoOrigem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tipoDocumentoOrigem':
            obj_ = tipoDocumentoOrigem.factory()
            obj_.build(child_)
            self.tipoDocumentoOrigem.append(obj_)
            obj_.original_tagname_ = 'tipoDocumentoOrigem'
# end class tiposDocumentosOrigem


class tipoDocumentoOrigem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, descricao=None):
        self.original_tagname_ = None
        self.codigo = codigo
        self.descricao = descricao
        self.validate_TString(self.descricao)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tipoDocumentoOrigem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tipoDocumentoOrigem.subclass:
            return tipoDocumentoOrigem.subclass(*args_, **kwargs_)
        else:
            return tipoDocumentoOrigem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_descricao(self): return self.descricao
    def set_descricao(self, descricao): self.descricao = descricao
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.codigo is not None or
            self.descricao is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tipoDocumentoOrigem', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tipoDocumentoOrigem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tipoDocumentoOrigem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tipoDocumentoOrigem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tipoDocumentoOrigem'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='tipoDocumentoOrigem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:codigo>%s</tns:codigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codigo), input_name='codigo')), eol_))
        if self.descricao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:descricao>%s</tns:descricao>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.descricao), input_name='descricao')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codigo':
            codigo_ = child_.text
            codigo_ = self.gds_validate_string(codigo_, node, 'codigo')
            self.codigo = codigo_
        elif nodeName_ == 'descricao':
            descricao_ = child_.text
            descricao_ = self.gds_validate_string(descricao_, node, 'descricao')
            self.descricao = descricao_
            # validate type TString
            self.validate_TString(self.descricao)
# end class tipoDocumentoOrigem


class exigeDataVencimento(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c14_dataVencimento', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeDataVencimento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeDataVencimento.subclass:
            return exigeDataVencimento.subclass(*args_, **kwargs_)
        else:
            return exigeDataVencimento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeDataVencimento', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeDataVencimento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeDataVencimento')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeDataVencimento', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeDataVencimento'):
        if self.campo != "c14_dataVencimento" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeDataVencimento', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeDataVencimento


class exigeDataPagamento(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c33_dataPagamento', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeDataPagamento)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeDataPagamento.subclass:
            return exigeDataPagamento.subclass(*args_, **kwargs_)
        else:
            return exigeDataPagamento(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeDataPagamento', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeDataPagamento')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeDataPagamento')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeDataPagamento', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeDataPagamento'):
        if self.campo != "c33_dataPagamento" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeDataPagamento', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeDataPagamento


class exigeConvenio(GeneratedsSuper):
    """N - Não exigido S - Opcional O - Exigido (deve-se informar)"""
    subclass = None
    superclass = None
    def __init__(self, campo='c15_convenio', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeConvenio)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeConvenio.subclass:
            return exigeConvenio.subclass(*args_, **kwargs_)
        else:
            return exigeConvenio(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeConvenio', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeConvenio')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeConvenio')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeConvenio', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeConvenio'):
        if self.campo != "c15_convenio" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeConvenio', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeConvenio


class exigeCamposAdicionais(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='c39_camposExtras', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exigeCamposAdicionais)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exigeCamposAdicionais.subclass:
            return exigeCamposAdicionais.subclass(*args_, **kwargs_)
        else:
            return exigeCamposAdicionais(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exigeCamposAdicionais', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exigeCamposAdicionais')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exigeCamposAdicionais')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exigeCamposAdicionais', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exigeCamposAdicionais'):
        if self.campo != "c39_camposExtras" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exigeCamposAdicionais', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exigeCamposAdicionais


class camposAdicionais(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campoAdicional=None):
        self.original_tagname_ = None
        if campoAdicional is None:
            self.campoAdicional = []
        else:
            self.campoAdicional = campoAdicional
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, camposAdicionais)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if camposAdicionais.subclass:
            return camposAdicionais.subclass(*args_, **kwargs_)
        else:
            return camposAdicionais(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campoAdicional(self): return self.campoAdicional
    def set_campoAdicional(self, campoAdicional): self.campoAdicional = campoAdicional
    def add_campoAdicional(self, value): self.campoAdicional.append(value)
    def insert_campoAdicional_at(self, index, value): self.campoAdicional.insert(index, value)
    def replace_campoAdicional_at(self, index, value): self.campoAdicional[index] = value
    def hasContent_(self):
        if (
            self.campoAdicional
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='camposAdicionais', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('camposAdicionais')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='camposAdicionais')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='camposAdicionais', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='camposAdicionais'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='camposAdicionais', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for campoAdicional_ in self.campoAdicional:
            campoAdicional_.export(outfile, level, namespace_, name_='campoAdicional', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'campoAdicional':
            obj_ = campoAdicional.factory()
            obj_.build(child_)
            self.campoAdicional.append(obj_)
            obj_.original_tagname_ = 'campoAdicional'
# end class camposAdicionais


class campoAdicional(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='campoExtra', obrigatorio=None, codigo=None, tipo=None, tamanho=None, casasDecimais=None, titulo=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.obrigatorio = obrigatorio
        self.validate_TSimNao(self.obrigatorio)
        self.codigo = codigo
        self.tipo = tipo
        self.tamanho = tamanho
        self.casasDecimais = casasDecimais
        self.titulo = titulo
        self.validate_TString(self.titulo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, campoAdicional)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if campoAdicional.subclass:
            return campoAdicional.subclass(*args_, **kwargs_)
        else:
            return campoAdicional(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_obrigatorio(self): return self.obrigatorio
    def set_obrigatorio(self, obrigatorio): self.obrigatorio = obrigatorio
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_tipo(self): return self.tipo
    def set_tipo(self, tipo): self.tipo = tipo
    def get_tamanho(self): return self.tamanho
    def set_tamanho(self, tamanho): self.tamanho = tamanho
    def get_casasDecimais(self): return self.casasDecimais
    def set_casasDecimais(self, casasDecimais): self.casasDecimais = casasDecimais
    def get_titulo(self): return self.titulo
    def set_titulo(self, titulo): self.titulo = titulo
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def validate_TSimNao(self, value):
        # Validate type TSimNao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TSimNao' % {"value" : value.encode("utf-8")} )
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.obrigatorio is not None or
            self.codigo is not None or
            self.tipo is not None or
            self.tamanho is not None or
            self.casasDecimais is not None or
            self.titulo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='campoAdicional', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('campoAdicional')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='campoAdicional')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='campoAdicional', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='campoAdicional'):
        if self.campo != "campoExtra" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='campoAdicional', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.obrigatorio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:obrigatorio>%s</tns:obrigatorio>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.obrigatorio), input_name='obrigatorio')), eol_))
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:codigo>%s</tns:codigo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.codigo), input_name='codigo')), eol_))
        if self.tipo is not None:
            self.tipo.export(outfile, level, namespace_, name_='tipo', pretty_print=pretty_print)
        if self.tamanho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:tamanho>%s</tns:tamanho>%s' % (self.gds_format_integer(self.tamanho, input_name='tamanho'), eol_))
        if self.casasDecimais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:casasDecimais>%s</tns:casasDecimais>%s' % (self.gds_format_integer(self.casasDecimais, input_name='casasDecimais'), eol_))
        if self.titulo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tns:titulo>%s</tns:titulo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.titulo), input_name='titulo')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'obrigatorio':
            obrigatorio_ = child_.text
            obrigatorio_ = self.gds_validate_string(obrigatorio_, node, 'obrigatorio')
            self.obrigatorio = obrigatorio_
            # validate type TSimNao
            self.validate_TSimNao(self.obrigatorio)
        elif nodeName_ == 'codigo':
            obj_ = string.factory()
            obj_.build(child_)
            self.codigo = obj_
            obj_.original_tagname_ = 'codigo'
        elif nodeName_ == 'tipo':
            obj_ = tipo.factory()
            obj_.build(child_)
            self.tipo = obj_
            obj_.original_tagname_ = 'tipo'
        elif nodeName_ == 'tamanho':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tamanho')
            self.tamanho = ival_
        elif nodeName_ == 'casasDecimais':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'casasDecimais')
            self.casasDecimais = ival_
        elif nodeName_ == 'titulo':
            titulo_ = child_.text
            titulo_ = self.gds_validate_string(titulo_, node, 'titulo')
            self.titulo = titulo_
            # validate type TString
            self.validate_TString(self.titulo)
# end class campoAdicional


class tipo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campo='tipo', valueOf_=None):
        self.original_tagname_ = None
        self.campo = _cast(None, campo)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tipo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tipo.subclass:
            return tipo.subclass(*args_, **kwargs_)
        else:
            return tipo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campo(self): return self.campo
    def set_campo(self, campo): self.campo = campo
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tipo', namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tipo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tipo')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tipo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tipo'):
        if self.campo != "tipo" and 'campo' not in already_processed:
            already_processed.add('campo')
            outfile.write(' campo=%s' % (quote_attrib(self.campo), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tipo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('campo', node)
        if value is not None and 'campo' not in already_processed:
            already_processed.add('campo')
            self.campo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tipo


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TConfigUf'
        rootClass = TConfigUf
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TConfigUf'
        rootClass = TConfigUf
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TConfigUf'
        rootClass = TConfigUf
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:tns="http://www.gnre.pe.gov.br"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TConfigUf'
        rootClass = TConfigUf
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from config_uf import *\n\n')
        sys.stdout.write('import config_uf as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TConfigUf"
]
