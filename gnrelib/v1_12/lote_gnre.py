#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Jun  6 08:51:35 2018 by generateDS.py version 2.29.15.
# Python 3.6.5 (default, Apr  1 2018, 05:46:30)  [GCC 7.3.0]
#
# Command line options:
#   ('-a', '')
#   ('-o', 'gnrelib/v1_12/lote_gnre.py')
#
# Command line arguments:
#   schemas/v1.12/lote_gnre_v1.00.xsd
#
# Command line:
#   /usr/local/bin/generateDS -a -o "gnrelib/v1_12/lote_gnre.py" schemas/v1.12/lote_gnre_v1.00.xsd
#
# Current working directory (os.getcwd()):
#   gnrelib
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class TLote_GNRE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, guias=None):
        self.original_tagname_ = None
        self.guias = guias
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLote_GNRE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLote_GNRE.subclass:
            return TLote_GNRE.subclass(*args_, **kwargs_)
        else:
            return TLote_GNRE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_guias(self): return self.guias
    def set_guias(self, guias): self.guias = guias
    def hasContent_(self):
        if (
            self.guias is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TLote_GNRE', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLote_GNRE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TLote_GNRE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TLote_GNRE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TLote_GNRE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TLote_GNRE', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.guias is not None:
            self.guias.export(outfile, level, namespace_, name_='guias', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'guias':
            obj_ = guiasType.factory()
            obj_.build(child_)
            self.guias = obj_
            obj_.original_tagname_ = 'guias'
# end class TLote_GNRE


class guiasType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TDadosGNRE=None):
        self.original_tagname_ = None
        if TDadosGNRE is None:
            self.TDadosGNRE = []
        else:
            self.TDadosGNRE = TDadosGNRE
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, guiasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if guiasType.subclass:
            return guiasType.subclass(*args_, **kwargs_)
        else:
            return guiasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TDadosGNRE(self): return self.TDadosGNRE
    def set_TDadosGNRE(self, TDadosGNRE): self.TDadosGNRE = TDadosGNRE
    def add_TDadosGNRE(self, value): self.TDadosGNRE.append(value)
    def insert_TDadosGNRE_at(self, index, value): self.TDadosGNRE.insert(index, value)
    def replace_TDadosGNRE_at(self, index, value): self.TDadosGNRE[index] = value
    def hasContent_(self):
        if (
            self.TDadosGNRE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='guiasType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('guiasType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='guiasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='guiasType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='guiasType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='guiasType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TDadosGNRE_ in self.TDadosGNRE:
            TDadosGNRE_.export(outfile, level, namespace_, name_='TDadosGNRE', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TDadosGNRE':
            obj_ = TDadosGNREType.factory()
            obj_.build(child_)
            self.TDadosGNRE.append(obj_)
            obj_.original_tagname_ = 'TDadosGNRE'
# end class guiasType


class TDadosGNREType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, c01_UfFavorecida=None, c02_receita=None, c25_detalhamentoReceita=None, c26_produto=None, c27_tipoIdentificacaoEmitente=None, c03_idContribuinteEmitente=None, c28_tipoDocOrigem=None, c04_docOrigem=None, c06_valorPrincipal=None, c10_valorTotal=None, c14_dataVencimento=None, c15_convenio=None, c16_razaoSocialEmitente=None, c17_inscricaoEstadualEmitente=None, c18_enderecoEmitente=None, c19_municipioEmitente=None, c20_ufEnderecoEmitente=None, c21_cepEmitente=None, c22_telefoneEmitente=None, c34_tipoIdentificacaoDestinatario=None, c35_idContribuinteDestinatario=None, c36_inscricaoEstadualDestinatario=None, c37_razaoSocialDestinatario=None, c38_municipioDestinatario=None, c33_dataPagamento=None, c05_referencia=None, c39_camposExtras=None, c42_identificadorGuia=None):
        self.original_tagname_ = None
        self.c01_UfFavorecida = c01_UfFavorecida
        self.validate_TUf(self.c01_UfFavorecida)
        self.c02_receita = c02_receita
        self.validate_c02_receitaType(self.c02_receita)
        self.c25_detalhamentoReceita = c25_detalhamentoReceita
        self.validate_c25_detalhamentoReceitaType(self.c25_detalhamentoReceita)
        self.c26_produto = c26_produto
        self.validate_c26_produtoType(self.c26_produto)
        self.c27_tipoIdentificacaoEmitente = c27_tipoIdentificacaoEmitente
        self.validate_TIdentificacao(self.c27_tipoIdentificacaoEmitente)
        self.c03_idContribuinteEmitente = c03_idContribuinteEmitente
        self.c28_tipoDocOrigem = c28_tipoDocOrigem
        self.validate_c28_tipoDocOrigemType(self.c28_tipoDocOrigem)
        self.c04_docOrigem = c04_docOrigem
        self.validate_c04_docOrigemType(self.c04_docOrigem)
        self.c06_valorPrincipal = c06_valorPrincipal
        self.validate_TDec_1502(self.c06_valorPrincipal)
        self.c10_valorTotal = c10_valorTotal
        self.validate_TDec_1502(self.c10_valorTotal)
        self.c14_dataVencimento = c14_dataVencimento
        self.validate_TData(self.c14_dataVencimento)
        self.c15_convenio = c15_convenio
        self.validate_c15_convenioType(self.c15_convenio)
        self.c16_razaoSocialEmitente = c16_razaoSocialEmitente
        self.validate_c16_razaoSocialEmitenteType(self.c16_razaoSocialEmitente)
        self.c17_inscricaoEstadualEmitente = c17_inscricaoEstadualEmitente
        self.validate_TIe(self.c17_inscricaoEstadualEmitente)
        self.c18_enderecoEmitente = c18_enderecoEmitente
        self.validate_c18_enderecoEmitenteType(self.c18_enderecoEmitente)
        self.c19_municipioEmitente = c19_municipioEmitente
        self.validate_TCodMunIBGE(self.c19_municipioEmitente)
        self.c20_ufEnderecoEmitente = c20_ufEnderecoEmitente
        self.validate_TUf(self.c20_ufEnderecoEmitente)
        self.c21_cepEmitente = c21_cepEmitente
        self.validate_c21_cepEmitenteType(self.c21_cepEmitente)
        self.c22_telefoneEmitente = c22_telefoneEmitente
        self.validate_c22_telefoneEmitenteType(self.c22_telefoneEmitente)
        self.c34_tipoIdentificacaoDestinatario = c34_tipoIdentificacaoDestinatario
        self.validate_TIdentificacao(self.c34_tipoIdentificacaoDestinatario)
        self.c35_idContribuinteDestinatario = c35_idContribuinteDestinatario
        self.c36_inscricaoEstadualDestinatario = c36_inscricaoEstadualDestinatario
        self.validate_TIe(self.c36_inscricaoEstadualDestinatario)
        self.c37_razaoSocialDestinatario = c37_razaoSocialDestinatario
        self.validate_c37_razaoSocialDestinatarioType(self.c37_razaoSocialDestinatario)
        self.c38_municipioDestinatario = c38_municipioDestinatario
        self.validate_TCodMunIBGE(self.c38_municipioDestinatario)
        self.c33_dataPagamento = c33_dataPagamento
        self.validate_TData(self.c33_dataPagamento)
        self.c05_referencia = c05_referencia
        self.c39_camposExtras = c39_camposExtras
        self.c42_identificadorGuia = c42_identificadorGuia
        self.validate_c42_identificadorGuiaType(self.c42_identificadorGuia)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TDadosGNREType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TDadosGNREType.subclass:
            return TDadosGNREType.subclass(*args_, **kwargs_)
        else:
            return TDadosGNREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_c01_UfFavorecida(self): return self.c01_UfFavorecida
    def set_c01_UfFavorecida(self, c01_UfFavorecida): self.c01_UfFavorecida = c01_UfFavorecida
    def get_c02_receita(self): return self.c02_receita
    def set_c02_receita(self, c02_receita): self.c02_receita = c02_receita
    def get_c25_detalhamentoReceita(self): return self.c25_detalhamentoReceita
    def set_c25_detalhamentoReceita(self, c25_detalhamentoReceita): self.c25_detalhamentoReceita = c25_detalhamentoReceita
    def get_c26_produto(self): return self.c26_produto
    def set_c26_produto(self, c26_produto): self.c26_produto = c26_produto
    def get_c27_tipoIdentificacaoEmitente(self): return self.c27_tipoIdentificacaoEmitente
    def set_c27_tipoIdentificacaoEmitente(self, c27_tipoIdentificacaoEmitente): self.c27_tipoIdentificacaoEmitente = c27_tipoIdentificacaoEmitente
    def get_c03_idContribuinteEmitente(self): return self.c03_idContribuinteEmitente
    def set_c03_idContribuinteEmitente(self, c03_idContribuinteEmitente): self.c03_idContribuinteEmitente = c03_idContribuinteEmitente
    def get_c28_tipoDocOrigem(self): return self.c28_tipoDocOrigem
    def set_c28_tipoDocOrigem(self, c28_tipoDocOrigem): self.c28_tipoDocOrigem = c28_tipoDocOrigem
    def get_c04_docOrigem(self): return self.c04_docOrigem
    def set_c04_docOrigem(self, c04_docOrigem): self.c04_docOrigem = c04_docOrigem
    def get_c06_valorPrincipal(self): return self.c06_valorPrincipal
    def set_c06_valorPrincipal(self, c06_valorPrincipal): self.c06_valorPrincipal = c06_valorPrincipal
    def get_c10_valorTotal(self): return self.c10_valorTotal
    def set_c10_valorTotal(self, c10_valorTotal): self.c10_valorTotal = c10_valorTotal
    def get_c14_dataVencimento(self): return self.c14_dataVencimento
    def set_c14_dataVencimento(self, c14_dataVencimento): self.c14_dataVencimento = c14_dataVencimento
    def get_c15_convenio(self): return self.c15_convenio
    def set_c15_convenio(self, c15_convenio): self.c15_convenio = c15_convenio
    def get_c16_razaoSocialEmitente(self): return self.c16_razaoSocialEmitente
    def set_c16_razaoSocialEmitente(self, c16_razaoSocialEmitente): self.c16_razaoSocialEmitente = c16_razaoSocialEmitente
    def get_c17_inscricaoEstadualEmitente(self): return self.c17_inscricaoEstadualEmitente
    def set_c17_inscricaoEstadualEmitente(self, c17_inscricaoEstadualEmitente): self.c17_inscricaoEstadualEmitente = c17_inscricaoEstadualEmitente
    def get_c18_enderecoEmitente(self): return self.c18_enderecoEmitente
    def set_c18_enderecoEmitente(self, c18_enderecoEmitente): self.c18_enderecoEmitente = c18_enderecoEmitente
    def get_c19_municipioEmitente(self): return self.c19_municipioEmitente
    def set_c19_municipioEmitente(self, c19_municipioEmitente): self.c19_municipioEmitente = c19_municipioEmitente
    def get_c20_ufEnderecoEmitente(self): return self.c20_ufEnderecoEmitente
    def set_c20_ufEnderecoEmitente(self, c20_ufEnderecoEmitente): self.c20_ufEnderecoEmitente = c20_ufEnderecoEmitente
    def get_c21_cepEmitente(self): return self.c21_cepEmitente
    def set_c21_cepEmitente(self, c21_cepEmitente): self.c21_cepEmitente = c21_cepEmitente
    def get_c22_telefoneEmitente(self): return self.c22_telefoneEmitente
    def set_c22_telefoneEmitente(self, c22_telefoneEmitente): self.c22_telefoneEmitente = c22_telefoneEmitente
    def get_c34_tipoIdentificacaoDestinatario(self): return self.c34_tipoIdentificacaoDestinatario
    def set_c34_tipoIdentificacaoDestinatario(self, c34_tipoIdentificacaoDestinatario): self.c34_tipoIdentificacaoDestinatario = c34_tipoIdentificacaoDestinatario
    def get_c35_idContribuinteDestinatario(self): return self.c35_idContribuinteDestinatario
    def set_c35_idContribuinteDestinatario(self, c35_idContribuinteDestinatario): self.c35_idContribuinteDestinatario = c35_idContribuinteDestinatario
    def get_c36_inscricaoEstadualDestinatario(self): return self.c36_inscricaoEstadualDestinatario
    def set_c36_inscricaoEstadualDestinatario(self, c36_inscricaoEstadualDestinatario): self.c36_inscricaoEstadualDestinatario = c36_inscricaoEstadualDestinatario
    def get_c37_razaoSocialDestinatario(self): return self.c37_razaoSocialDestinatario
    def set_c37_razaoSocialDestinatario(self, c37_razaoSocialDestinatario): self.c37_razaoSocialDestinatario = c37_razaoSocialDestinatario
    def get_c38_municipioDestinatario(self): return self.c38_municipioDestinatario
    def set_c38_municipioDestinatario(self, c38_municipioDestinatario): self.c38_municipioDestinatario = c38_municipioDestinatario
    def get_c33_dataPagamento(self): return self.c33_dataPagamento
    def set_c33_dataPagamento(self, c33_dataPagamento): self.c33_dataPagamento = c33_dataPagamento
    def get_c05_referencia(self): return self.c05_referencia
    def set_c05_referencia(self, c05_referencia): self.c05_referencia = c05_referencia
    def get_c39_camposExtras(self): return self.c39_camposExtras
    def set_c39_camposExtras(self, c39_camposExtras): self.c39_camposExtras = c39_camposExtras
    def get_c42_identificadorGuia(self): return self.c42_identificadorGuia
    def set_c42_identificadorGuia(self, c42_identificadorGuia): self.c42_identificadorGuia = c42_identificadorGuia
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_c02_receitaType(self, value):
        # Validate type c02_receitaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c02_receitaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c02_receitaType_patterns_, ))
    validate_c02_receitaType_patterns_ = [['^[0-9]{6}$']]
    def validate_c25_detalhamentoReceitaType(self, value):
        # Validate type c25_detalhamentoReceitaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c25_detalhamentoReceitaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c25_detalhamentoReceitaType_patterns_, ))
    validate_c25_detalhamentoReceitaType_patterns_ = [['^[0-9]{6}$']]
    def validate_c26_produtoType(self, value):
        # Validate type c26_produtoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c26_produtoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c26_produtoType_patterns_, ))
    validate_c26_produtoType_patterns_ = [['^[1-9]{1}[0-9]{0,3}$']]
    def validate_TIdentificacao(self, value):
        # Validate type TIdentificacao, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TIdentificacao' % {"value" : value.encode("utf-8")} )
    def validate_c28_tipoDocOrigemType(self, value):
        # Validate type c28_tipoDocOrigemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c28_tipoDocOrigemType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c28_tipoDocOrigemType_patterns_, ))
    validate_c28_tipoDocOrigemType_patterns_ = [['^[0-9]{2}$']]
    def validate_c04_docOrigemType(self, value):
        # Validate type c04_docOrigemType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c04_docOrigemType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c04_docOrigemType_patterns_, ))
    validate_c04_docOrigemType_patterns_ = [['^[0-9]{1,18}$']]
    def validate_TDec_1502(self, value):
        # Validate type TDec_1502, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1502_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1502_patterns_, ))
    validate_TDec_1502_patterns_ = [['^0$|^0\\.[0-9]{2}$|^[1-9]{1}[0-9]{0,9}(\\.[0-9]{2})?$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [['^(((20(([02468][048])$|^([13579][26]))-02-29))$|^(20[0-9][0-9])-((((0[1-9])$|^(1[0-2]))-((0[1-9])$|^(1\\d)$|^(2[0-8])))$|^((((0[13578])$|^(1[02]))-31)$|^(((0[1,3-9])$|^(1[0-2]))-(29$|^30)))))$']]
    def validate_c15_convenioType(self, value):
        # Validate type c15_convenioType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on c15_convenioType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_c15_convenioType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c15_convenioType_patterns_, ))
    validate_c15_convenioType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_c16_razaoSocialEmitenteType(self, value):
        # Validate type c16_razaoSocialEmitenteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on c16_razaoSocialEmitenteType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_c16_razaoSocialEmitenteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c16_razaoSocialEmitenteType_patterns_, ))
    validate_c16_razaoSocialEmitenteType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TIe(self, value):
        # Validate type TIe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TIe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIe_patterns_, ))
    validate_TIe_patterns_ = [['^[0-9]{2,16}$']]
    def validate_c18_enderecoEmitenteType(self, value):
        # Validate type c18_enderecoEmitenteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on c18_enderecoEmitenteType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_c18_enderecoEmitenteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c18_enderecoEmitenteType_patterns_, ))
    validate_c18_enderecoEmitenteType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [['^[0-9]{5}$']]
    def validate_c21_cepEmitenteType(self, value):
        # Validate type c21_cepEmitenteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c21_cepEmitenteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c21_cepEmitenteType_patterns_, ))
    validate_c21_cepEmitenteType_patterns_ = [['^[0-9]{8}$']]
    def validate_c22_telefoneEmitenteType(self, value):
        # Validate type c22_telefoneEmitenteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_c22_telefoneEmitenteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c22_telefoneEmitenteType_patterns_, ))
    validate_c22_telefoneEmitenteType_patterns_ = [['^[0-9]{6,11}$']]
    def validate_c37_razaoSocialDestinatarioType(self, value):
        # Validate type c37_razaoSocialDestinatarioType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on c37_razaoSocialDestinatarioType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_c37_razaoSocialDestinatarioType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c37_razaoSocialDestinatarioType_patterns_, ))
    validate_c37_razaoSocialDestinatarioType_patterns_ = [['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def validate_c42_identificadorGuiaType(self, value):
        # Validate type c42_identificadorGuiaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 10:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on c42_identificadorGuiaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_c42_identificadorGuiaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_c42_identificadorGuiaType_patterns_, ))
    validate_c42_identificadorGuiaType_patterns_ = [['^[0-9]{1,10}$'], ['^[!-ÿ]{1}[ -ÿ]{0,}[!-ÿ]{1}$|^[!-ÿ]{1}$']]
    def hasContent_(self):
        if (
            self.c01_UfFavorecida is not None or
            self.c02_receita is not None or
            self.c25_detalhamentoReceita is not None or
            self.c26_produto is not None or
            self.c27_tipoIdentificacaoEmitente is not None or
            self.c03_idContribuinteEmitente is not None or
            self.c28_tipoDocOrigem is not None or
            self.c04_docOrigem is not None or
            self.c06_valorPrincipal is not None or
            self.c10_valorTotal is not None or
            self.c14_dataVencimento is not None or
            self.c15_convenio is not None or
            self.c16_razaoSocialEmitente is not None or
            self.c17_inscricaoEstadualEmitente is not None or
            self.c18_enderecoEmitente is not None or
            self.c19_municipioEmitente is not None or
            self.c20_ufEnderecoEmitente is not None or
            self.c21_cepEmitente is not None or
            self.c22_telefoneEmitente is not None or
            self.c34_tipoIdentificacaoDestinatario is not None or
            self.c35_idContribuinteDestinatario is not None or
            self.c36_inscricaoEstadualDestinatario is not None or
            self.c37_razaoSocialDestinatario is not None or
            self.c38_municipioDestinatario is not None or
            self.c33_dataPagamento is not None or
            self.c05_referencia is not None or
            self.c39_camposExtras is not None or
            self.c42_identificadorGuia is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TDadosGNREType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TDadosGNREType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TDadosGNREType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TDadosGNREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TDadosGNREType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TDadosGNREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.c01_UfFavorecida is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c01_UfFavorecida>%s</c01_UfFavorecida>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c01_UfFavorecida), input_name='c01_UfFavorecida')), eol_))
        if self.c02_receita is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c02_receita>%s</c02_receita>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c02_receita), input_name='c02_receita')), eol_))
        if self.c25_detalhamentoReceita is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c25_detalhamentoReceita>%s</c25_detalhamentoReceita>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c25_detalhamentoReceita), input_name='c25_detalhamentoReceita')), eol_))
        if self.c26_produto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c26_produto>%s</c26_produto>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c26_produto), input_name='c26_produto')), eol_))
        if self.c27_tipoIdentificacaoEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c27_tipoIdentificacaoEmitente>%s</c27_tipoIdentificacaoEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c27_tipoIdentificacaoEmitente), input_name='c27_tipoIdentificacaoEmitente')), eol_))
        if self.c03_idContribuinteEmitente is not None:
            self.c03_idContribuinteEmitente.export(outfile, level, namespace_, name_='c03_idContribuinteEmitente', pretty_print=pretty_print)
        if self.c28_tipoDocOrigem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c28_tipoDocOrigem>%s</c28_tipoDocOrigem>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c28_tipoDocOrigem), input_name='c28_tipoDocOrigem')), eol_))
        if self.c04_docOrigem is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c04_docOrigem>%s</c04_docOrigem>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c04_docOrigem), input_name='c04_docOrigem')), eol_))
        if self.c06_valorPrincipal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c06_valorPrincipal>%s</c06_valorPrincipal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c06_valorPrincipal), input_name='c06_valorPrincipal')), eol_))
        if self.c10_valorTotal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c10_valorTotal>%s</c10_valorTotal>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c10_valorTotal), input_name='c10_valorTotal')), eol_))
        if self.c14_dataVencimento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c14_dataVencimento>%s</c14_dataVencimento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c14_dataVencimento), input_name='c14_dataVencimento')), eol_))
        if self.c15_convenio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c15_convenio>%s</c15_convenio>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c15_convenio), input_name='c15_convenio')), eol_))
        if self.c16_razaoSocialEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c16_razaoSocialEmitente>%s</c16_razaoSocialEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c16_razaoSocialEmitente), input_name='c16_razaoSocialEmitente')), eol_))
        if self.c17_inscricaoEstadualEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c17_inscricaoEstadualEmitente>%s</c17_inscricaoEstadualEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c17_inscricaoEstadualEmitente), input_name='c17_inscricaoEstadualEmitente')), eol_))
        if self.c18_enderecoEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c18_enderecoEmitente>%s</c18_enderecoEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c18_enderecoEmitente), input_name='c18_enderecoEmitente')), eol_))
        if self.c19_municipioEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c19_municipioEmitente>%s</c19_municipioEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c19_municipioEmitente), input_name='c19_municipioEmitente')), eol_))
        if self.c20_ufEnderecoEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c20_ufEnderecoEmitente>%s</c20_ufEnderecoEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c20_ufEnderecoEmitente), input_name='c20_ufEnderecoEmitente')), eol_))
        if self.c21_cepEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c21_cepEmitente>%s</c21_cepEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c21_cepEmitente), input_name='c21_cepEmitente')), eol_))
        if self.c22_telefoneEmitente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c22_telefoneEmitente>%s</c22_telefoneEmitente>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c22_telefoneEmitente), input_name='c22_telefoneEmitente')), eol_))
        if self.c34_tipoIdentificacaoDestinatario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c34_tipoIdentificacaoDestinatario>%s</c34_tipoIdentificacaoDestinatario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c34_tipoIdentificacaoDestinatario), input_name='c34_tipoIdentificacaoDestinatario')), eol_))
        if self.c35_idContribuinteDestinatario is not None:
            self.c35_idContribuinteDestinatario.export(outfile, level, namespace_, name_='c35_idContribuinteDestinatario', pretty_print=pretty_print)
        if self.c36_inscricaoEstadualDestinatario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c36_inscricaoEstadualDestinatario>%s</c36_inscricaoEstadualDestinatario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c36_inscricaoEstadualDestinatario), input_name='c36_inscricaoEstadualDestinatario')), eol_))
        if self.c37_razaoSocialDestinatario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c37_razaoSocialDestinatario>%s</c37_razaoSocialDestinatario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c37_razaoSocialDestinatario), input_name='c37_razaoSocialDestinatario')), eol_))
        if self.c38_municipioDestinatario is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c38_municipioDestinatario>%s</c38_municipioDestinatario>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c38_municipioDestinatario), input_name='c38_municipioDestinatario')), eol_))
        if self.c33_dataPagamento is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c33_dataPagamento>%s</c33_dataPagamento>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c33_dataPagamento), input_name='c33_dataPagamento')), eol_))
        if self.c05_referencia is not None:
            self.c05_referencia.export(outfile, level, namespace_, name_='c05_referencia', pretty_print=pretty_print)
        if self.c39_camposExtras is not None:
            self.c39_camposExtras.export(outfile, level, namespace_, name_='c39_camposExtras', pretty_print=pretty_print)
        if self.c42_identificadorGuia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<c42_identificadorGuia>%s</c42_identificadorGuia>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.c42_identificadorGuia), input_name='c42_identificadorGuia')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'c01_UfFavorecida':
            c01_UfFavorecida_ = child_.text
            c01_UfFavorecida_ = self.gds_validate_string(c01_UfFavorecida_, node, 'c01_UfFavorecida')
            self.c01_UfFavorecida = c01_UfFavorecida_
            # validate type TUf
            self.validate_TUf(self.c01_UfFavorecida)
        elif nodeName_ == 'c02_receita':
            c02_receita_ = child_.text
            c02_receita_ = self.gds_validate_string(c02_receita_, node, 'c02_receita')
            self.c02_receita = c02_receita_
            # validate type c02_receitaType
            self.validate_c02_receitaType(self.c02_receita)
        elif nodeName_ == 'c25_detalhamentoReceita':
            c25_detalhamentoReceita_ = child_.text
            c25_detalhamentoReceita_ = self.gds_validate_string(c25_detalhamentoReceita_, node, 'c25_detalhamentoReceita')
            self.c25_detalhamentoReceita = c25_detalhamentoReceita_
            # validate type c25_detalhamentoReceitaType
            self.validate_c25_detalhamentoReceitaType(self.c25_detalhamentoReceita)
        elif nodeName_ == 'c26_produto':
            c26_produto_ = child_.text
            c26_produto_ = self.gds_validate_string(c26_produto_, node, 'c26_produto')
            self.c26_produto = c26_produto_
            # validate type c26_produtoType
            self.validate_c26_produtoType(self.c26_produto)
        elif nodeName_ == 'c27_tipoIdentificacaoEmitente':
            c27_tipoIdentificacaoEmitente_ = child_.text
            c27_tipoIdentificacaoEmitente_ = self.gds_validate_string(c27_tipoIdentificacaoEmitente_, node, 'c27_tipoIdentificacaoEmitente')
            self.c27_tipoIdentificacaoEmitente = c27_tipoIdentificacaoEmitente_
            # validate type TIdentificacao
            self.validate_TIdentificacao(self.c27_tipoIdentificacaoEmitente)
        elif nodeName_ == 'c03_idContribuinteEmitente':
            obj_ = c03_idContribuinteEmitenteType.factory()
            obj_.build(child_)
            self.c03_idContribuinteEmitente = obj_
            obj_.original_tagname_ = 'c03_idContribuinteEmitente'
        elif nodeName_ == 'c28_tipoDocOrigem':
            c28_tipoDocOrigem_ = child_.text
            c28_tipoDocOrigem_ = self.gds_validate_string(c28_tipoDocOrigem_, node, 'c28_tipoDocOrigem')
            self.c28_tipoDocOrigem = c28_tipoDocOrigem_
            # validate type c28_tipoDocOrigemType
            self.validate_c28_tipoDocOrigemType(self.c28_tipoDocOrigem)
        elif nodeName_ == 'c04_docOrigem':
            c04_docOrigem_ = child_.text
            c04_docOrigem_ = self.gds_validate_string(c04_docOrigem_, node, 'c04_docOrigem')
            self.c04_docOrigem = c04_docOrigem_
            # validate type c04_docOrigemType
            self.validate_c04_docOrigemType(self.c04_docOrigem)
        elif nodeName_ == 'c06_valorPrincipal':
            c06_valorPrincipal_ = child_.text
            c06_valorPrincipal_ = self.gds_validate_string(c06_valorPrincipal_, node, 'c06_valorPrincipal')
            self.c06_valorPrincipal = c06_valorPrincipal_
            # validate type TDec_1502
            self.validate_TDec_1502(self.c06_valorPrincipal)
        elif nodeName_ == 'c10_valorTotal':
            c10_valorTotal_ = child_.text
            c10_valorTotal_ = self.gds_validate_string(c10_valorTotal_, node, 'c10_valorTotal')
            self.c10_valorTotal = c10_valorTotal_
            # validate type TDec_1502
            self.validate_TDec_1502(self.c10_valorTotal)
        elif nodeName_ == 'c14_dataVencimento':
            c14_dataVencimento_ = child_.text
            c14_dataVencimento_ = self.gds_validate_string(c14_dataVencimento_, node, 'c14_dataVencimento')
            self.c14_dataVencimento = c14_dataVencimento_
            # validate type TData
            self.validate_TData(self.c14_dataVencimento)
        elif nodeName_ == 'c15_convenio':
            c15_convenio_ = child_.text
            c15_convenio_ = self.gds_validate_string(c15_convenio_, node, 'c15_convenio')
            self.c15_convenio = c15_convenio_
            # validate type c15_convenioType
            self.validate_c15_convenioType(self.c15_convenio)
        elif nodeName_ == 'c16_razaoSocialEmitente':
            c16_razaoSocialEmitente_ = child_.text
            c16_razaoSocialEmitente_ = self.gds_validate_string(c16_razaoSocialEmitente_, node, 'c16_razaoSocialEmitente')
            self.c16_razaoSocialEmitente = c16_razaoSocialEmitente_
            # validate type c16_razaoSocialEmitenteType
            self.validate_c16_razaoSocialEmitenteType(self.c16_razaoSocialEmitente)
        elif nodeName_ == 'c17_inscricaoEstadualEmitente':
            c17_inscricaoEstadualEmitente_ = child_.text
            c17_inscricaoEstadualEmitente_ = self.gds_validate_string(c17_inscricaoEstadualEmitente_, node, 'c17_inscricaoEstadualEmitente')
            self.c17_inscricaoEstadualEmitente = c17_inscricaoEstadualEmitente_
            # validate type TIe
            self.validate_TIe(self.c17_inscricaoEstadualEmitente)
        elif nodeName_ == 'c18_enderecoEmitente':
            c18_enderecoEmitente_ = child_.text
            c18_enderecoEmitente_ = self.gds_validate_string(c18_enderecoEmitente_, node, 'c18_enderecoEmitente')
            self.c18_enderecoEmitente = c18_enderecoEmitente_
            # validate type c18_enderecoEmitenteType
            self.validate_c18_enderecoEmitenteType(self.c18_enderecoEmitente)
        elif nodeName_ == 'c19_municipioEmitente':
            c19_municipioEmitente_ = child_.text
            c19_municipioEmitente_ = self.gds_validate_string(c19_municipioEmitente_, node, 'c19_municipioEmitente')
            self.c19_municipioEmitente = c19_municipioEmitente_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.c19_municipioEmitente)
        elif nodeName_ == 'c20_ufEnderecoEmitente':
            c20_ufEnderecoEmitente_ = child_.text
            c20_ufEnderecoEmitente_ = self.gds_validate_string(c20_ufEnderecoEmitente_, node, 'c20_ufEnderecoEmitente')
            self.c20_ufEnderecoEmitente = c20_ufEnderecoEmitente_
            # validate type TUf
            self.validate_TUf(self.c20_ufEnderecoEmitente)
        elif nodeName_ == 'c21_cepEmitente':
            c21_cepEmitente_ = child_.text
            c21_cepEmitente_ = self.gds_validate_string(c21_cepEmitente_, node, 'c21_cepEmitente')
            self.c21_cepEmitente = c21_cepEmitente_
            # validate type c21_cepEmitenteType
            self.validate_c21_cepEmitenteType(self.c21_cepEmitente)
        elif nodeName_ == 'c22_telefoneEmitente':
            c22_telefoneEmitente_ = child_.text
            c22_telefoneEmitente_ = self.gds_validate_string(c22_telefoneEmitente_, node, 'c22_telefoneEmitente')
            self.c22_telefoneEmitente = c22_telefoneEmitente_
            # validate type c22_telefoneEmitenteType
            self.validate_c22_telefoneEmitenteType(self.c22_telefoneEmitente)
        elif nodeName_ == 'c34_tipoIdentificacaoDestinatario':
            c34_tipoIdentificacaoDestinatario_ = child_.text
            c34_tipoIdentificacaoDestinatario_ = self.gds_validate_string(c34_tipoIdentificacaoDestinatario_, node, 'c34_tipoIdentificacaoDestinatario')
            self.c34_tipoIdentificacaoDestinatario = c34_tipoIdentificacaoDestinatario_
            # validate type TIdentificacao
            self.validate_TIdentificacao(self.c34_tipoIdentificacaoDestinatario)
        elif nodeName_ == 'c35_idContribuinteDestinatario':
            obj_ = c35_idContribuinteDestinatarioType.factory()
            obj_.build(child_)
            self.c35_idContribuinteDestinatario = obj_
            obj_.original_tagname_ = 'c35_idContribuinteDestinatario'
        elif nodeName_ == 'c36_inscricaoEstadualDestinatario':
            c36_inscricaoEstadualDestinatario_ = child_.text
            c36_inscricaoEstadualDestinatario_ = self.gds_validate_string(c36_inscricaoEstadualDestinatario_, node, 'c36_inscricaoEstadualDestinatario')
            self.c36_inscricaoEstadualDestinatario = c36_inscricaoEstadualDestinatario_
            # validate type TIe
            self.validate_TIe(self.c36_inscricaoEstadualDestinatario)
        elif nodeName_ == 'c37_razaoSocialDestinatario':
            c37_razaoSocialDestinatario_ = child_.text
            c37_razaoSocialDestinatario_ = self.gds_validate_string(c37_razaoSocialDestinatario_, node, 'c37_razaoSocialDestinatario')
            self.c37_razaoSocialDestinatario = c37_razaoSocialDestinatario_
            # validate type c37_razaoSocialDestinatarioType
            self.validate_c37_razaoSocialDestinatarioType(self.c37_razaoSocialDestinatario)
        elif nodeName_ == 'c38_municipioDestinatario':
            c38_municipioDestinatario_ = child_.text
            c38_municipioDestinatario_ = self.gds_validate_string(c38_municipioDestinatario_, node, 'c38_municipioDestinatario')
            self.c38_municipioDestinatario = c38_municipioDestinatario_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.c38_municipioDestinatario)
        elif nodeName_ == 'c33_dataPagamento':
            c33_dataPagamento_ = child_.text
            c33_dataPagamento_ = self.gds_validate_string(c33_dataPagamento_, node, 'c33_dataPagamento')
            self.c33_dataPagamento = c33_dataPagamento_
            # validate type TData
            self.validate_TData(self.c33_dataPagamento)
        elif nodeName_ == 'c05_referencia':
            obj_ = c05_referenciaType.factory()
            obj_.build(child_)
            self.c05_referencia = obj_
            obj_.original_tagname_ = 'c05_referencia'
        elif nodeName_ == 'c39_camposExtras':
            obj_ = c39_camposExtrasType.factory()
            obj_.build(child_)
            self.c39_camposExtras = obj_
            obj_.original_tagname_ = 'c39_camposExtras'
        elif nodeName_ == 'c42_identificadorGuia':
            c42_identificadorGuia_ = child_.text
            c42_identificadorGuia_ = self.gds_validate_string(c42_identificadorGuia_, node, 'c42_identificadorGuia')
            self.c42_identificadorGuia = c42_identificadorGuia_
            # validate type c42_identificadorGuiaType
            self.validate_c42_identificadorGuiaType(self.c42_identificadorGuia)
# end class TDadosGNREType


class c03_idContribuinteEmitenteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, c03_idContribuinteEmitenteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if c03_idContribuinteEmitenteType.subclass:
            return c03_idContribuinteEmitenteType.subclass(*args_, **kwargs_)
        else:
            return c03_idContribuinteEmitenteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='c03_idContribuinteEmitenteType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('c03_idContribuinteEmitenteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='c03_idContribuinteEmitenteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='c03_idContribuinteEmitenteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='c03_idContribuinteEmitenteType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='c03_idContribuinteEmitenteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class c03_idContribuinteEmitenteType


class c35_idContribuinteDestinatarioType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None):
        self.original_tagname_ = None
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, c35_idContribuinteDestinatarioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if c35_idContribuinteDestinatarioType.subclass:
            return c35_idContribuinteDestinatarioType.subclass(*args_, **kwargs_)
        else:
            return c35_idContribuinteDestinatarioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self): return self.CNPJ
    def set_CNPJ(self, CNPJ): self.CNPJ = CNPJ
    def get_CPF(self): return self.CPF
    def set_CPF(self, CPF): self.CPF = CPF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [['^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [['^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='c35_idContribuinteDestinatarioType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('c35_idContribuinteDestinatarioType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='c35_idContribuinteDestinatarioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='c35_idContribuinteDestinatarioType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='c35_idContribuinteDestinatarioType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='c35_idContribuinteDestinatarioType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CNPJ>%s</CNPJ>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<CPF>%s</CPF>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class c35_idContribuinteDestinatarioType


class c05_referenciaType(GeneratedsSuper):
    """Informações de período de apuração"""
    subclass = None
    superclass = None
    def __init__(self, periodo=None, mes=None, ano=None, parcela=None):
        self.original_tagname_ = None
        self.periodo = periodo
        self.validate_periodoType(self.periodo)
        self.mes = mes
        self.validate_TMes(self.mes)
        self.ano = ano
        self.validate_TAno(self.ano)
        self.parcela = parcela
        self.validate_parcelaType(self.parcela)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, c05_referenciaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if c05_referenciaType.subclass:
            return c05_referenciaType.subclass(*args_, **kwargs_)
        else:
            return c05_referenciaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_periodo(self): return self.periodo
    def set_periodo(self, periodo): self.periodo = periodo
    def get_mes(self): return self.mes
    def set_mes(self, mes): self.mes = mes
    def get_ano(self): return self.ano
    def set_ano(self, ano): self.ano = ano
    def get_parcela(self): return self.parcela
    def set_parcela(self, parcela): self.parcela = parcela
    def validate_periodoType(self, value):
        # Validate type periodoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on periodoType' % {"value" : value.encode("utf-8")} )
    def validate_TMes(self, value):
        # Validate type TMes, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TMes' % {"value" : value.encode("utf-8")} )
    def validate_TAno(self, value):
        # Validate type TAno, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TAno_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TAno_patterns_, ))
    validate_TAno_patterns_ = [['^[1-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}$']]
    def validate_parcelaType(self, value):
        # Validate type parcelaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_parcelaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_parcelaType_patterns_, ))
    validate_parcelaType_patterns_ = [['^[1-9]{1}[0-9]{0,2}$']]
    def hasContent_(self):
        if (
            self.periodo is not None or
            self.mes is not None or
            self.ano is not None or
            self.parcela is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='c05_referenciaType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('c05_referenciaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='c05_referenciaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='c05_referenciaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='c05_referenciaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='c05_referenciaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.periodo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<periodo>%s</periodo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.periodo), input_name='periodo')), eol_))
        if self.mes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<mes>%s</mes>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.mes), input_name='mes')), eol_))
        if self.ano is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ano>%s</ano>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.ano), input_name='ano')), eol_))
        if self.parcela is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<parcela>%s</parcela>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.parcela), input_name='parcela')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'periodo':
            periodo_ = child_.text
            periodo_ = self.gds_validate_string(periodo_, node, 'periodo')
            self.periodo = periodo_
            # validate type periodoType
            self.validate_periodoType(self.periodo)
        elif nodeName_ == 'mes':
            mes_ = child_.text
            mes_ = self.gds_validate_string(mes_, node, 'mes')
            self.mes = mes_
            # validate type TMes
            self.validate_TMes(self.mes)
        elif nodeName_ == 'ano':
            ano_ = child_.text
            ano_ = self.gds_validate_string(ano_, node, 'ano')
            self.ano = ano_
            # validate type TAno
            self.validate_TAno(self.ano)
        elif nodeName_ == 'parcela':
            parcela_ = child_.text
            parcela_ = self.gds_validate_string(parcela_, node, 'parcela')
            self.parcela = parcela_
            # validate type parcelaType
            self.validate_parcelaType(self.parcela)
# end class c05_referenciaType


class c39_camposExtrasType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, campoExtra=None):
        self.original_tagname_ = None
        if campoExtra is None:
            self.campoExtra = []
        else:
            self.campoExtra = campoExtra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, c39_camposExtrasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if c39_camposExtrasType.subclass:
            return c39_camposExtrasType.subclass(*args_, **kwargs_)
        else:
            return c39_camposExtrasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_campoExtra(self): return self.campoExtra
    def set_campoExtra(self, campoExtra): self.campoExtra = campoExtra
    def add_campoExtra(self, value): self.campoExtra.append(value)
    def insert_campoExtra_at(self, index, value): self.campoExtra.insert(index, value)
    def replace_campoExtra_at(self, index, value): self.campoExtra[index] = value
    def hasContent_(self):
        if (
            self.campoExtra
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='c39_camposExtrasType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('c39_camposExtrasType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='c39_camposExtrasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='c39_camposExtrasType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='c39_camposExtrasType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='c39_camposExtrasType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for campoExtra_ in self.campoExtra:
            campoExtra_.export(outfile, level, namespace_, name_='campoExtra', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'campoExtra':
            obj_ = campoExtraType.factory()
            obj_.build(child_)
            self.campoExtra.append(obj_)
            obj_.original_tagname_ = 'campoExtra'
# end class c39_camposExtrasType


class campoExtraType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, codigo=None, tipo=None, valor=None):
        self.original_tagname_ = None
        self.codigo = codigo
        self.tipo = tipo
        self.validate_TTipoCampoExtra(self.tipo)
        self.valor = valor
        self.validate_valorType(self.valor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, campoExtraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if campoExtraType.subclass:
            return campoExtraType.subclass(*args_, **kwargs_)
        else:
            return campoExtraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_codigo(self): return self.codigo
    def set_codigo(self, codigo): self.codigo = codigo
    def get_tipo(self): return self.tipo
    def set_tipo(self, tipo): self.tipo = tipo
    def get_valor(self): return self.valor
    def set_valor(self, valor): self.valor = valor
    def validate_TTipoCampoExtra(self, value):
        # Validate type TTipoCampoExtra, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['T', 'N', 'D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TTipoCampoExtra' % {"value" : value.encode("utf-8")} )
    def validate_valorType(self, value):
        # Validate type valorType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 100:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on valorType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.codigo is not None or
            self.tipo is not None or
            self.valor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='campoExtraType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('campoExtraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='campoExtraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='campoExtraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='campoExtraType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='campoExtraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.codigo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<codigo>%s</codigo>%s' % (self.gds_format_integer(self.codigo, input_name='codigo'), eol_))
        if self.tipo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<tipo>%s</tipo>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.tipo), input_name='tipo')), eol_))
        if self.valor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<valor>%s</valor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.valor), input_name='valor')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'codigo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'codigo')
            self.codigo = ival_
        elif nodeName_ == 'tipo':
            tipo_ = child_.text
            tipo_ = self.gds_validate_string(tipo_, node, 'tipo')
            self.tipo = tipo_
            # validate type TTipoCampoExtra
            self.validate_TTipoCampoExtra(self.tipo)
        elif nodeName_ == 'valor':
            valor_ = child_.text
            valor_ = self.gds_validate_string(valor_, node, 'valor')
            self.valor = valor_
            # validate type valorType
            self.validate_valorType(self.valor)
# end class campoExtraType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TLote_GNRE'
        rootClass = TLote_GNRE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TLote_GNRE'
        rootClass = TLote_GNRE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TLote_GNRE'
        rootClass = TLote_GNRE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TLote_GNRE'
        rootClass = TLote_GNRE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from lote_gnre import *\n\n')
        sys.stdout.write('import lote_gnre as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "TDadosGNREType",
    "TLote_GNRE",
    "c03_idContribuinteEmitenteType",
    "c05_referenciaType",
    "c35_idContribuinteDestinatarioType",
    "c39_camposExtrasType",
    "campoExtraType",
    "guiasType"
]
